package it.dontesta.labs.quarkus.poc.security.iod.evil;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import it.dontesta.labs.quarkus.poc.security.iod.safe.SafeClass;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InvalidClassException;
import java.io.ObjectInputFilter;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import org.jboss.logging.Logger;
import org.junit.jupiter.api.Test;

/**
 * Classe di test che dimostra le vulnerabilità di serializzazione Java e le relative mitigazioni.
 * <p>
 * Questa classe crea un'istanza serializzata della classe {@code Exploit} che contiene
 * codice potenzialmente dannoso. Il test verifica:
 * <ul>
 *   <li>La capacità di serializzare un payload malevolo su file</li>
 *   <li>L'efficacia dei filtri di sicurezza nel bloccare la deserializzazione di classi non sicure</li>
 * </ul>
 * <p>
 * Il test genera due file di payload:
 * <ul>
 *   <li>{@value #PAYLOAD_FILE} - Usato per test interni e cancellato al completamento</li>
 *   <li>{@value #PAYLOAD_FILE_TO_TESTING} - Persistente per test degli endpoint REST</li>
 * </ul>
 * <p>
 * Questa classe dimostra la vulnerabilità OWASP A8:2017 Deserializzazione Insicura e
 * l'approccio di mitigazione usando {@link ObjectInputFilter}. L'implementazione mostra
 * come consentire solo oggetti da uno specifico package sicuro ({@value #SAFE_PACKAGE})
 * respingendo tutti gli altri.
 *
 * @see ObjectInputFilter
 * @see Exploit
 */
class ExploitSerializationTest {

  private static final Logger log = Logger.getLogger(ExploitSerializationTest.class);

  // File di payload
  private static final String PAYLOAD_FILE = "target/exploit-payload.ser";

  // File di payload per il testing via REST
  private static final String PAYLOAD_FILE_TO_TESTING = "target/exploit-payload-to-testing.ser";

  // File di payload sicuro
  private static final String PAYLOAD_FILE_SAFE = "target/safe-payload.ser";

  // File di payload sicuro per il testing via REST
  private static final String PAYLOAD_FILE_SAFE_TO_TESTING = "target/safe-payload-to-testing.ser";

  // Package che contiene classi sicure
  private static final String SAFE_PACKAGE = "it.dontesta.labs.quarkus.poc.security.iod.safe";


  @Test
  void testPayloadSerialization() throws IOException {
    // Serializzazione dell'oggetto malevolo
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(PAYLOAD_FILE))) {
      oos.writeObject(new Exploit());
    }

    // Verifica che il file sia stato creato
    File file = new File(PAYLOAD_FILE);
    assertTrue(file.exists(), "Il file di payload non è stato creato!");

    // Deserializzazione sicura con filtro per bloccare Exploit
    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PAYLOAD_FILE))) {
      ois.setObjectInputFilter(info -> {
        if (info.serialClass() != null &&
            info.serialClass().getName().startsWith(SAFE_PACKAGE)) {
          return ObjectInputFilter.Status.ALLOWED;
        }
        return ObjectInputFilter.Status.REJECTED;
      });

      // Prova a deserializzare
      ois.readObject();

      // Se arriva qui, significa che Exploit è stato deserializzato (errore di sicurezza!)
      fail("Deserializzazione di Exploit eseguita! Pericolo di RCE!");
    } catch (InvalidClassException e) {
      // Successo: Exploit è stato bloccato!
      log.infof("Deserializzazione bloccata con successo: %s", e.getMessage());
    } catch (ClassNotFoundException e) {
      log.errorf("Classe non trovata durante la deserializzazione: %s ", e.getMessage());
    }

    // Copia del file di payload per il testing via REST
    final Path path = Files.copy(file.toPath(), new File(PAYLOAD_FILE_TO_TESTING).toPath(),
        StandardCopyOption.REPLACE_EXISTING);

    log.infof("File di payload per il testing via REST: %s ", path);

    // Pulizia del file dopo il test
    file.delete();
  }

  @Test
  void testSafeClassSerialization() throws IOException, ClassNotFoundException {
    // Creazione dell'oggetto SafeClass
    SafeClass originalObject = new SafeClass("Test sicuro", 100);

    // Serializzazione dell'oggetto sicuro
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(PAYLOAD_FILE_SAFE))) {
      oos.writeObject(originalObject);
    }

    // Verifica che il file sia stato creato
    File file = new File(PAYLOAD_FILE_SAFE);
    assertTrue(file.exists(), "Il file di payload sicuro non è stato creato!");

    // Deserializzazione con filtro che permette solo classi sicure
    SafeClass deserializedObject = null;
    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(PAYLOAD_FILE_SAFE))) {
      ois.setObjectInputFilter(info -> {
        if (info.serialClass() != null &&
            info.serialClass().getName().startsWith(SAFE_PACKAGE)) {
          return ObjectInputFilter.Status.ALLOWED;
        }
        return ObjectInputFilter.Status.REJECTED;
      });

      // Deserializzazione e cast al tipo corretto
      deserializedObject = (SafeClass) ois.readObject();

      // Verifica che l'oggetto sia stato deserializzato correttamente
      assertTrue(deserializedObject != null, "L'oggetto deserializzato è nullo!");
      assertEquals(originalObject.getName(), deserializedObject.getName(), "Il nome non corrisponde!");
      assertEquals(originalObject.getValue(), deserializedObject.getValue(), "Il valore non corrisponde!");

      log.infof("Deserializzazione di SafeClass completata con successo: %s", deserializedObject);
    }

    // Copia del file di payload per il testing via REST
    final Path path = Files.copy(file.toPath(), new File(PAYLOAD_FILE_SAFE_TO_TESTING).toPath(),
        StandardCopyOption.REPLACE_EXISTING);

    log.infof("File di payload sicuro per il testing via REST: %s", path);

    // Pulizia del file dopo il test
    file.delete();
  }
}